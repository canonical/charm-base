# Copyright 2024 Canonical Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Common code for the unit testing frameworks for charms."""

import dataclasses
import datetime
import fnmatch
import http
import os
import pathlib
import shutil
import signal
from io import BytesIO, IOBase, StringIO
from typing import (
    Any,
    BinaryIO,
    Dict,
    Iterable,
    List,
    Optional,
    Set,
    TextIO,
    Tuple,
    TypeVar,
    Union,
    cast,
)

from ops import charm, pebble
from ops.model import Container

ReadableBuffer = Union[bytes, str, StringIO, BytesIO, BinaryIO]

# CharmType represents user charms that are derived from CharmBase.
CharmType = TypeVar('CharmType', bound=charm.CharmBase)


@dataclasses.dataclass
class ExecArgs:
    """Represent arguments captured from the :meth:`ops.Container.exec` method call.

    These arguments will be passed to the :meth:`Harness.handle_exec` handler function.
    See :meth:`ops.pebble.Client.exec` for documentation of properties.
    """

    command: List[str]
    environment: Dict[str, str]
    working_dir: Optional[str]
    timeout: Optional[float]
    user_id: Optional[int]
    user: Optional[str]
    group_id: Optional[int]
    group: Optional[str]
    stdin: Optional[Union[str, bytes]]
    encoding: Optional[str]
    combine_stderr: bool


@dataclasses.dataclass(frozen=True)
class ActionOutput:
    """Contains the logs and results from a :meth:`Harness.run_action` call."""

    logs: List[str]
    """Messages generated by the Charm using :meth:`ops.ActionEvent.log`."""

    results: Dict[str, Any]
    """The action's results, as set or updated by :meth:`ops.ActionEvent.set_results`."""


class ActionFailed(Exception):  # noqa
    """Raised when :code:`event.fail()` is called in an action event handler."""

    message: str
    """Optional details of the failure, as provided by :meth:`ops.ActionEvent.fail`."""

    output: ActionOutput
    """Any logs and results set by the Charm.

    Both logs and results will be empty unless Harness is used to run the action.
    """

    def __init__(self, message: str, *, output: Optional[ActionOutput]):
        self.message = message
        if output is None:
            output = ActionOutput(logs=[], results={})
        self.output = output

    def __str__(self):
        if self.message:
            return self.message
        return 'Event handler called `fail()` with no additional details.'


def _copy_docstrings(source_cls: Any):
    """Copy the docstrings from source_cls to target_cls.

    Use this as:
      @_copy_docstrings(source_class)
      class TargetClass:

    And for any public method that exists on both classes, it will copy the
    __doc__ for that method.
    """

    def decorator(target_cls: Any):
        for meth_name in target_cls.__dict__:
            if meth_name.startswith('_'):
                continue
            source_method = source_cls.__dict__.get(meth_name)
            if source_method is not None and source_method.__doc__:
                target_cls.__dict__[meth_name].__doc__ = source_method.__doc__
        return target_cls

    return decorator


@_copy_docstrings(pebble.Client)
class _TestingPebbleClient:
    """This conforms to the interface for pebble.Client but provides canned data.

    DO NOT use this class directly, it is used by the unit test framework to run
    interactions with Pebble. The unit test framework is responsible for
    maintaining the internal consistency of the values here, as the only public
    methods of this type are for implementing Client.
    """

    def __init__(self, container_root: pathlib.Path):
        self._root = container_root
        self._notices: Dict[Tuple[str, str], pebble.Notice] = {}
        self._check_infos: Dict[str, pebble.CheckInfo] = {}
        self._last_notice_id = 0
        self._changes: Dict[str, pebble.Change] = {}

    def _check_connection(self):
        raise NotImplementedError(self._check_connection)

    @property
    def _layers(self):
        raise NotImplementedError(self._layers)

    @property
    def _service_status(self):
        raise NotImplementedError(self._service_status)

    def get_system_info(self) -> pebble.SystemInfo:
        self._check_connection()
        return pebble.SystemInfo(version='1.0.0')

    def get_warnings(
        self,
        select: pebble.WarningState = pebble.WarningState.PENDING,
    ) -> List['pebble.Warning']:
        raise NotImplementedError(self.get_warnings)

    def ack_warnings(self, timestamp: datetime.datetime) -> int:
        raise NotImplementedError(self.ack_warnings)

    def get_changes(
        self,
        select: pebble.ChangeState = pebble.ChangeState.IN_PROGRESS,
        service: Optional[str] = None,
    ) -> List[pebble.Change]:
        raise NotImplementedError(self.get_changes)

    def get_change(self, change_id: str) -> pebble.Change:
        self._check_connection()
        try:
            return self._changes[change_id]
        except KeyError:
            message = f'cannot find change with id "{change_id}"'
            raise self._api_error(404, message) from None

    def abort_change(self, change_id: pebble.ChangeID) -> pebble.Change:
        raise NotImplementedError(self.abort_change)

    def autostart_services(self, timeout: float = 30.0, delay: float = 0.1):
        self._check_connection()
        for name, service in self._render_services().items():
            # TODO: jam 2021-04-20 This feels awkward that Service.startup might be a string or
            #  might be an enum. Probably should make Service.startup a property rather than an
            #  attribute.
            if service.startup == '':
                startup = pebble.ServiceStartup.DISABLED
            else:
                startup = pebble.ServiceStartup(service.startup)
            if startup == pebble.ServiceStartup.ENABLED:
                self._service_status[name] = pebble.ServiceStatus.ACTIVE

    def replan_services(self, timeout: float = 30.0, delay: float = 0.1):
        return self.autostart_services(timeout, delay)

    def start_services(
        self,
        services: List[str],
        timeout: float = 30.0,
        delay: float = 0.1,
    ):
        # A common mistake is to pass just the name of a service, rather than a list of services,
        # so trap that so it is caught quickly.
        if isinstance(services, str):
            raise TypeError(f'start_services should take a list of names, not just "{services}"')

        self._check_connection()

        # Note: jam 2021-04-20 We don't implement ChangeID, but the default caller of this is
        # Container.start() which currently ignores the return value
        known_services = self._render_services()
        # Names appear to be validated before any are activated, so do two passes
        for name in services:
            if name not in known_services:
                # TODO: jam 2021-04-20 This needs a better error type
                raise RuntimeError(f'400 Bad Request: service "{name}" does not exist')
        for name in services:
            self._service_status[name] = pebble.ServiceStatus.ACTIVE

    def stop_services(
        self,
        services: List[str],
        timeout: float = 30.0,
        delay: float = 0.1,
    ):
        # handle a common mistake of passing just a name rather than a list of names
        if isinstance(services, str):
            raise TypeError(f'stop_services should take a list of names, not just "{services}"')

        self._check_connection()

        # Note: jam 2021-04-20 We don't implement ChangeID, but the default caller of this is
        # Container.stop() which currently ignores the return value
        known_services = self._render_services()
        for name in services:
            if name not in known_services:
                # TODO: jam 2021-04-20 This needs a better error type
                #  400 Bad Request: service "bal" does not exist
                raise RuntimeError(f'400 Bad Request: service "{name}" does not exist')
        for name in services:
            self._service_status[name] = pebble.ServiceStatus.INACTIVE

    def restart_services(
        self,
        services: List[str],
        timeout: float = 30.0,
        delay: float = 0.1,
    ):
        # handle a common mistake of passing just a name rather than a list of names
        if isinstance(services, str):
            raise TypeError(f'restart_services should take a list of names, not just "{services}"')

        self._check_connection()

        # Note: jam 2021-04-20 We don't implement ChangeID, but the default caller of this is
        # Container.restart() which currently ignores the return value
        known_services = self._render_services()
        for name in services:
            if name not in known_services:
                # TODO: jam 2021-04-20 This needs a better error type
                #  400 Bad Request: service "bal" does not exist
                raise RuntimeError(f'400 Bad Request: service "{name}" does not exist')
        for name in services:
            self._service_status[name] = pebble.ServiceStatus.ACTIVE

    def wait_change(
        self,
        change_id: pebble.ChangeID,
        timeout: float = 30.0,
        delay: float = 0.1,
    ) -> pebble.Change:
        raise NotImplementedError(self.wait_change)

    def add_layer(
        self,
        label: str,
        layer: Union[str, 'pebble.LayerDict', pebble.Layer],
        *,
        combine: bool = False,
    ):
        # I wish we could combine some of this helpful object corralling with the actual backend,
        # rather than having to re-implement it. Maybe we could subclass
        if not isinstance(label, str):
            raise TypeError(f'label must be a str, not {type(label).__name__}')

        if isinstance(layer, (str, dict)):
            layer_obj = pebble.Layer(layer)
        elif isinstance(layer, pebble.Layer):
            layer_obj = layer
        else:
            raise TypeError(
                f'layer must be str, dict, or pebble.Layer, not {type(layer).__name__}'
            )

        self._check_connection()

        if label in self._layers:
            if not combine:
                raise RuntimeError(f'400 Bad Request: layer "{label}" already exists')
            layer = self._layers[label]

            for name, service in layer_obj.services.items():
                # 'override' is actually single quoted in the real error, but
                # it shouldn't be, hopefully that gets cleaned up.
                if not service.override:
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" must define'
                        f'"override" for service "{name}"'
                    )
                if service.override not in ('merge', 'replace'):
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" has invalid '
                        f'"override" value on service "{name}"'
                    )
                elif service.override == 'replace':
                    layer.services[name] = service
                elif service.override == 'merge':
                    if combine and name in layer.services:
                        layer.services[name]._merge(service)
                    else:
                        layer.services[name] = service

            for name, check in layer_obj.checks.items():
                if not check.override:
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" must define'
                        f'"override" for check "{name}"'
                    )
                if check.override not in ('merge', 'replace'):
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" has invalid '
                        f'"override" value for check "{name}"'
                    )
                elif check.override == 'replace':
                    layer.checks[name] = check
                elif check.override == 'merge':
                    if combine and name in layer.checks:
                        layer.checks[name]._merge(check)
                    else:
                        layer.checks[name] = check

            for name, log_target in layer_obj.log_targets.items():
                if not log_target.override:
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" must define'
                        f'"override" for log target "{name}"'
                    )
                if log_target.override not in ('merge', 'replace'):
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" has invalid '
                        f'"override" value for log target "{name}"'
                    )
                elif log_target.override == 'replace':
                    layer.log_targets[name] = log_target
                elif log_target.override == 'merge':
                    if combine and name in layer.log_targets:
                        layer.log_targets[name]._merge(log_target)
                    else:
                        layer.log_targets[name] = log_target

        else:
            self._layers[label] = layer_obj

    def _render_services(self) -> Dict[str, pebble.Service]:
        services: Dict[str, pebble.Service] = {}
        for key in sorted(self._layers.keys()):
            layer = self._layers[key]
            for name, service in layer.services.items():
                # TODO: merge existing services https://github.com/canonical/operator/issues/1112
                services[name] = service
        return services

    def _render_checks(self) -> Dict[str, pebble.Check]:
        checks: Dict[str, pebble.Check] = {}
        for key in sorted(self._layers.keys()):
            layer = self._layers[key]
            for name, check in layer.checks.items():
                checks[name] = check
        return checks

    def _render_log_targets(self) -> Dict[str, pebble.LogTarget]:
        log_targets: Dict[str, pebble.LogTarget] = {}
        for key in sorted(self._layers.keys()):
            layer = self._layers[key]
            for name, log_target in layer.log_targets.items():
                log_targets[name] = log_target
        return log_targets

    def get_plan(self) -> pebble.Plan:
        self._check_connection()
        plan = pebble.Plan('{}')
        plan.services.update(self._render_services())
        plan.checks.update(self._render_checks())
        plan.log_targets.update(self._render_log_targets())
        return plan

    def get_services(self, names: Optional[List[str]] = None) -> List[pebble.ServiceInfo]:
        if isinstance(names, str):
            raise TypeError(f'start_services should take a list of names, not just "{names}"')

        self._check_connection()
        services = self._render_services()
        infos: List[pebble.ServiceInfo] = []
        if names is None:
            names = sorted(services.keys())
        for name in sorted(names):
            try:
                service = services[name]
            except KeyError:
                # in pebble, it just returns "nothing matched" if there are 0 matches,
                # but it ignores services it doesn't recognize
                continue
            status = self._service_status.get(name, pebble.ServiceStatus.INACTIVE)
            if service.startup == '':
                startup = pebble.ServiceStartup.DISABLED
            else:
                startup = pebble.ServiceStartup(service.startup)
            info = pebble.ServiceInfo(name, startup=startup, current=pebble.ServiceStatus(status))
            infos.append(info)
        return infos

    @staticmethod
    def _check_absolute_path(path: str):
        if not path.startswith('/'):
            raise pebble.PathError('generic-file-error', f'paths must be absolute, got {path!r}')

    def pull(self, path: str, *, encoding: Optional[str] = 'utf-8') -> Union[BinaryIO, TextIO]:
        self._check_connection()
        self._check_absolute_path(path)
        file_path = self._root / path[1:]
        try:
            return cast(
                Union[BinaryIO, TextIO],
                file_path.open('rb' if encoding is None else 'r', encoding=encoding),
            )
        except FileNotFoundError:
            raise pebble.PathError(
                'not-found', f'stat {path}: no such file or directory'
            ) from None
        except IsADirectoryError:
            raise pebble.PathError(
                'generic-file-error', f'can only read a regular file: "{path}"'
            ) from None

    def push(
        self,
        path: str,
        source: 'ReadableBuffer',
        *,
        encoding: str = 'utf-8',
        make_dirs: bool = False,
        permissions: Optional[int] = None,
        user_id: Optional[int] = None,
        user: Optional[str] = None,
        group_id: Optional[int] = None,
        group: Optional[str] = None,
    ) -> None:
        self._check_connection()
        if permissions is not None and not (0 <= permissions <= 0o777):
            raise pebble.PathError(
                'generic-file-error', f'permissions not within 0o000 to 0o777: {permissions:#o}'
            )
        self._check_absolute_path(path)
        file_path = self._root / path[1:]
        if make_dirs and not file_path.parent.exists():
            self.make_dir(
                os.path.dirname(path),
                make_parents=True,
                permissions=None,
                user_id=user_id,
                user=user,
                group_id=group_id,
                group=group,
            )
        permissions = permissions if permissions is not None else 0o644
        try:
            if isinstance(source, str):
                file_path.write_text(source, encoding=encoding)
            elif isinstance(source, bytes):
                file_path.write_bytes(source)
            else:
                # If source is binary, open file in binary mode and ignore encoding param
                is_binary = isinstance(source.read(0), bytes)  # type: ignore
                open_mode = 'wb' if is_binary else 'w'
                open_encoding = None if is_binary else encoding
                with file_path.open(open_mode, encoding=open_encoding) as f:
                    shutil.copyfileobj(cast(IOBase, source), cast(IOBase, f))
            os.chmod(file_path, permissions)
        except FileNotFoundError as e:
            raise pebble.PathError(
                'not-found', f'parent directory not found: {e.args[0]}'
            ) from None
        except NotADirectoryError:
            raise pebble.PathError(
                'generic-file-error', f'open {path}.~: not a directory'
            ) from None

    def list_files(
        self, path: str, *, pattern: Optional[str] = None, itself: bool = False
    ) -> List[pebble.FileInfo]:
        self._check_connection()
        self._check_absolute_path(path)
        file_path = self._root / path[1:]
        if not file_path.exists():
            raise self._api_error(404, f'stat {path}: no such file or directory')
        files = [file_path]
        if not itself:
            try:
                files = [file_path / file for file in os.listdir(file_path)]
            except NotADirectoryError:
                pass

        if pattern is not None:
            files = [file for file in files if fnmatch.fnmatch(file.name, pattern)]

        file_infos = [Container._build_fileinfo(file) for file in files]
        for file_info in file_infos:
            rel_path = os.path.relpath(file_info.path, start=self._root)
            rel_path = '/' if rel_path == '.' else '/' + rel_path
            file_info.path = rel_path
            if rel_path == '/':
                file_info.name = '/'
        return file_infos

    def make_dir(
        self,
        path: str,
        *,
        make_parents: bool = False,
        permissions: Optional[int] = None,
        user_id: Optional[int] = None,
        user: Optional[str] = None,
        group_id: Optional[int] = None,
        group: Optional[str] = None,
    ) -> None:
        self._check_connection()
        if permissions is not None and not (0 <= permissions <= 0o777):
            raise pebble.PathError(
                'generic-file-error', f'permissions not within 0o000 to 0o777: {permissions:#o}'
            )
        self._check_absolute_path(path)
        dir_path = self._root / path[1:]
        if not dir_path.parent.exists() and not make_parents:
            raise pebble.PathError('not-found', f'parent directory not found: {path}')
        if not dir_path.parent.exists() and make_parents:
            self.make_dir(
                os.path.dirname(path),
                make_parents=True,
                permissions=permissions,
                user_id=user_id,
                user=user,
                group_id=group_id,
                group=group,
            )
        try:
            permissions = permissions if permissions else 0o755
            dir_path.mkdir()
            os.chmod(dir_path, permissions)
        except FileExistsError:
            if not make_parents:
                raise pebble.PathError(
                    'generic-file-error', f'mkdir {path}: file exists'
                ) from None
        except NotADirectoryError as e:
            # Attempted to create a subdirectory of a file
            raise pebble.PathError('generic-file-error', f'not a directory: {e.args[0]}') from None

    def remove_path(self, path: str, *, recursive: bool = False):
        self._check_connection()
        self._check_absolute_path(path)
        file_path = self._root / path[1:]
        if not file_path.exists():
            if recursive:
                return
            raise pebble.PathError('not-found', f'remove {path}: no such file or directory')
        if file_path.is_dir():
            if recursive:
                shutil.rmtree(file_path)
            else:
                try:
                    file_path.rmdir()
                except OSError as e:
                    raise pebble.PathError(
                        'generic-file-error',
                        'cannot remove non-empty directory without recursive=True',
                    ) from e
        else:
            file_path.unlink()

    def send_signal(self, sig: Union[int, str], service_names: Iterable[str]):
        if not service_names:
            raise TypeError('send_signal expected at least 1 service name, got 0')
        self._check_connection()

        # Convert signal to str
        if isinstance(sig, int):
            sig = signal.Signals(sig).name

        # pebble first validates the service name, and then the signal name

        plan = self.get_plan()
        for service in service_names:
            if service not in plan.services or not self.get_services([service])[0].is_running():
                # conform with the real pebble api
                message = f'cannot send signal to "{service}": service is not running'
                raise self._api_error(500, message)

        # Check if signal name is valid
        try:
            signal.Signals[sig]
        except KeyError:
            # conform with the real pebble api
            first_service = next(iter(service_names))
            message = f'cannot send signal to "{first_service}": invalid signal name "{sig}"'
            raise self._api_error(500, message) from None

    def get_checks(
        self, level: Optional[pebble.CheckLevel] = None, names: Optional[Iterable[str]] = None
    ) -> List[pebble.CheckInfo]:
        if names is not None:
            names = frozenset(names)
        return [
            info
            for info in self._check_infos.values()
            if (level is None or level == info.level) and (names is None or info.name in names)
        ]

    def notify(
        self,
        type: pebble.NoticeType,
        key: str,
        *,
        data: Optional[Dict[str, str]] = None,
        repeat_after: Optional[datetime.timedelta] = None,
    ) -> str:
        notice_id, _ = self._notify(type, key, data=data, repeat_after=repeat_after)
        return notice_id

    def _notify(
        self,
        type: pebble.NoticeType,
        key: str,
        *,
        data: Optional[Dict[str, str]] = None,
        repeat_after: Optional[datetime.timedelta] = None,
    ) -> Tuple[str, bool]:
        """Record an occurrence of a notice with the specified details.

        Return a tuple of (notice_id, new_or_repeated).
        """
        # The shape of the code below is taken from State.AddNotice in Pebble.
        now = datetime.datetime.now(tz=datetime.timezone.utc)

        new_or_repeated = False
        unique_key = (type.value, key)
        notice = self._notices.get(unique_key)
        if notice is None:
            # First occurrence of this notice uid+type+key
            self._last_notice_id += 1
            notice = pebble.Notice(
                id=str(self._last_notice_id),
                user_id=0,  # Charm should always be able to read pebble_notify notices.
                type=type,
                key=key,
                first_occurred=now,
                last_occurred=now,
                last_repeated=now,
                expire_after=datetime.timedelta(days=7),
                occurrences=1,
                last_data=data or {},
                repeat_after=repeat_after,
            )
            self._notices[unique_key] = notice
            new_or_repeated = True
        else:
            # Additional occurrence, update existing notice
            last_repeated = notice.last_repeated
            if repeat_after is None or now > notice.last_repeated + repeat_after:
                # Update last repeated time if repeat-after time has elapsed (or is None)
                last_repeated = now
                new_or_repeated = True
            notice = dataclasses.replace(
                notice,
                last_occurred=now,
                last_repeated=last_repeated,
                occurrences=notice.occurrences + 1,
                last_data=data or {},
                repeat_after=repeat_after,
            )
            self._notices[unique_key] = notice

        return notice.id, new_or_repeated

    def _api_error(self, code: int, message: str) -> pebble.APIError:
        status = http.HTTPStatus(code).phrase
        body = {
            'type': 'error',
            'status-code': code,
            'status': status,
            'result': {'message': message},
        }
        return pebble.APIError(body, code, status, message)

    def get_notice(self, id: str) -> pebble.Notice:
        for notice in self._notices.values():
            if notice.id == id:
                return notice
        raise self._api_error(404, f'cannot find notice with ID "{id}"')

    def get_notices(
        self,
        *,
        users: Optional[pebble.NoticesUsers] = None,
        user_id: Optional[int] = None,
        types: Optional[Iterable[Union[pebble.NoticeType, str]]] = None,
        keys: Optional[Iterable[str]] = None,
    ) -> List[pebble.Notice]:
        # Similar logic as api_notices.go:v1GetNotices in Pebble.

        filter_user_id = 0  # default is to filter by request UID (root)
        if user_id is not None:
            filter_user_id = user_id
        if users is not None:
            if user_id is not None:
                raise self._api_error(400, 'cannot use both "users" and "user_id"')
            filter_user_id = None

        if types is not None:
            types = {(t.value if isinstance(t, pebble.NoticeType) else t) for t in types}
        if keys is not None:
            keys = set(keys)

        notices = [
            notice
            for notice in self._notices.values()
            if self._notice_matches(notice, filter_user_id, types, keys)
        ]
        notices.sort(key=lambda notice: notice.last_repeated)
        return notices

    @staticmethod
    def _notice_matches(
        notice: pebble.Notice,
        user_id: Optional[int] = None,
        types: Optional[Set[str]] = None,
        keys: Optional[Set[str]] = None,
    ) -> bool:
        # Same logic as NoticeFilter.matches in Pebble.
        # For example: if user_id filter is set and it doesn't match, return False.
        if user_id is not None and not (notice.user_id is None or user_id == notice.user_id):
            return False
        if types is not None and notice.type not in types:
            return False
        if keys is not None and notice.key not in keys:
            return False
        return True
