# Copyright 2020 Canonical Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""Implements the requires side handling of the 'tls-certificates' interface.

`CAClient`_ is the type providing integration with a certificate authority charm providing the
tls-certificates interface.

     from pathlib import Path
     from ops.lib.tls_certificates.ca_client import CAClient

     class MyCharm(ops.charm.CharmBase):

        TLS_CONFIG_PATH = Path("/tls/config/path/for/your/app")
        TLS_KEY_PATH = TLS_CONFIG_PATH / 'key.pem'
        TLS_CERT_PATH = TLS_CONFIG_PATH / 'cert.pem'
        TLS_CA_CERT_PATH = TLS_CONFIG_PATH / 'ca.pem'

        def __init__(self, framework):
           super().__init__(framework, None)
           self.ca_client = CAClient(self, 'ca-client')
           self.framework.observe(self.ca_client.on.tls_config_ready, self._on_tls_config_ready)
           self.framework.observe(self.ca_client.on.ca_available, self._on_ca_available)
        ...
        def _on_ca_available(self, event):
            # ...
            # Obtain a common name and a list of subject alternative names to place into
            # certificates to be generated by a certificate authority and expose them to the CA.
            self.ca_client.request_server_certificate(common_name, sans)

        def _on_tls_config_ready(self, event):
            # When TLS config is ready, a CA certificate, requested certificate and key will be
            # available from an instance of CAClient. It can be written to the target files and
            # used by the target application.
            self.TLS_KEY_PATH.write_bytes(self.ca_client.key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=serialization.NoEncryption(),
            ))
            self.TLS_CERT_PATH.write_bytes(
                self.ca_client.certificate.public_bytes(encoding=serialization.Encoding.PEM))
            self.TLS_CA_CERT_PATH.write_bytes(
                self.ca_client.ca_certificate.public_bytes(encoding=serialization.Encoding.PEM))
            # And then reconfigure and reload your application.
            # ...
"""


from ops.framework import Object, EventBase, EventSetBase, EventSource, StoredState
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.x509 import load_pem_x509_certificate

import json
import logging

logger = logging.getLogger(__name__)


class CAAvailable(EventBase):
    pass


class TlsConfigReady(EventBase):
    pass


class CAClientEvents(EventSetBase):
    ca_available = EventSource(CAAvailable)
    tls_config_ready = EventSource(TlsConfigReady)


class CAClient(Object):

    on = CAClientEvents()
    stored = StoredState()

    def __init__(self, charm, relation_name):
        super().__init__(charm, relation_name)
        self._relation_name = relation_name
        self._common_name = None
        self._sans = None

        self.stored.set_default(ca_certificate=None, key=None, certificate=None)

        self.framework.observe(charm.on[relation_name].relation_joined, self._on_relation_joined)
        self.framework.observe(charm.on[relation_name].relation_changed, self._on_relation_changed)

    @property
    def is_joined(self):
        return self.framework.model.get_relation(self._relation_name) is not None

    @property
    def is_ready(self):
        return all(p is not None for p in (self.stored.certificate, self.stored.key,
                                           self.stored.ca_certificate))

    @property
    def certificate(self):
        return load_pem_x509_certificate(self.stored.certificate.encode('utf-8'),
                                         backend=default_backend())

    @property
    def key(self):
        return load_pem_private_key(self.stored.key.encode('utf-8'), password=None,
                                    backend=default_backend())

    @property
    def ca_certificate(self):
        return load_pem_x509_certificate(self.stored.ca_certificate.encode('utf-8'),
                                         backend=default_backend())

    def _on_relation_joined(self, event):
        self.on.ca_available.emit()

    def request_server_certificate(self, common_name, sans):
        """Request a new server certificate.

        If arguments do not change from a previous request, then a new certificate will not
        be requested. This method can be useful if a list of SANS has changed during the
        lifetime of a charm.

        common_name -- a new common name to use.
        sans -- an updated list of Subject Alternative Names to use.
        """
        rel = self.framework.model.get_relation(self._relation_name)
        logger.info('Requesting a CA certificate. Common name: {}, SANS: {}'
                    ''.format(common_name, sans))
        rel_data = rel.data[self.model.unit]
        rel_data['common_name'] = common_name
        rel_data['sans'] = json.dumps(sans)

    def _on_relation_changed(self, event):
        # easy-rsa is not HA so there is only one unit to work with and Vault
        # uses one leader unit to write responses and does not (at the time
        # of writing) rely on app relation data.
        remote_data = event.relation.data[event.unit]

        cert = remote_data.get('{}.server.cert'.format(self.model.unit.name.replace("/", "_")))
        key = remote_data.get('{}.server.key'.format(self.model.unit.name.replace("/", "_")))
        ca = remote_data.get('ca')
        if cert is None or key is None or ca is None:
            logger.info('A CA has not yet exposed a requested certificate,'
                        ' key and CA certificate.')
            return
        self.stored.certificate = cert
        self.stored.key = key
        self.stored.ca_certificate = ca
        self.on.tls_config_ready.emit()
